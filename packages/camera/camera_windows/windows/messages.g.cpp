// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace camera_windows {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
  return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '" + channel_name + "'.",
      EncodableValue(""));
}

// PlatformSize

PlatformSize::PlatformSize(double width, double height)
    : width_(width), height_(height) {}

double PlatformSize::width() const { return width_; }

void PlatformSize::set_width(double value_arg) { width_ = value_arg; }

double PlatformSize::height() const { return height_; }

void PlatformSize::set_height(double value_arg) { height_ = value_arg; }

EncodableList PlatformSize::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(width_));
  list.push_back(EncodableValue(height_));
  return list;
}

PlatformSize PlatformSize::FromEncodableList(const EncodableList& list) {
  PlatformSize decoded(std::get<double>(list[0]), std::get<double>(list[1]));
  return decoded;
}

// PlatformVideoCaptureOptions

PlatformVideoCaptureOptions::PlatformVideoCaptureOptions(
    int64_t max_duration_milliseconds)
    : max_duration_milliseconds_(max_duration_milliseconds) {}

int64_t PlatformVideoCaptureOptions::max_duration_milliseconds() const {
  return max_duration_milliseconds_;
}

void PlatformVideoCaptureOptions::set_max_duration_milliseconds(
    int64_t value_arg) {
  max_duration_milliseconds_ = value_arg;
}

EncodableList PlatformVideoCaptureOptions::ToEncodableList() const {
  EncodableList list;
  list.reserve(1);
  list.push_back(EncodableValue(max_duration_milliseconds_));
  return list;
}

PlatformVideoCaptureOptions PlatformVideoCaptureOptions::FromEncodableList(
    const EncodableList& list) {
  PlatformVideoCaptureOptions decoded(list[0].LongValue());
  return decoded;
}

CameraApiCodecSerializer::CameraApiCodecSerializer() {}

EncodableValue CameraApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(PlatformSize::FromEncodableList(
          std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(
          PlatformVideoCaptureOptions::FromEncodableList(
              std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void CameraApiCodecSerializer::WriteValue(
    const EncodableValue& value, flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value =
          std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(PlatformSize)) {
      stream->WriteByte(128);
      WriteValue(
          EncodableValue(
              std::any_cast<PlatformSize>(*custom_value).ToEncodableList()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(PlatformVideoCaptureOptions)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(
                     std::any_cast<PlatformVideoCaptureOptions>(*custom_value)
                         .ToEncodableList()),
                 stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by CameraApi.
const flutter::StandardMessageCodec& CameraApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &CameraApiCodecSerializer::GetInstance());
}

// Sets up an instance of `CameraApi` to handle messages through the
// `binary_messenger`.
void CameraApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                      CameraApi* api) {
  CameraApi::SetUp(binary_messenger, api, "");
}

void CameraApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                      CameraApi* api,
                      const std::string& message_channel_suffix) {
  const std::string prepended_suffix =
      message_channel_suffix.length() > 0
          ? std::string(".") + message_channel_suffix
          : "";
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.availableCameras" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              ErrorOr<EncodableList> output = api->AvailableCameras();
              if (output.has_error()) {
                reply(WrapError(output.error()));
                return;
              }
              EncodableList wrapped;
              wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
              reply(EncodableValue(std::move(wrapped)));
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.create" + prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_name_arg = args.at(0);
              if (encodable_camera_name_arg.IsNull()) {
                reply(WrapError("camera_name_arg unexpectedly null."));
                return;
              }
              const auto& camera_name_arg =
                  std::get<std::string>(encodable_camera_name_arg);
              const auto& encodable_resolution_preset_arg = args.at(1);
              const int64_t resolution_preset_arg_value =
                  encodable_resolution_preset_arg.IsNull()
                      ? 0
                      : encodable_resolution_preset_arg.LongValue();
              const auto resolution_preset_arg =
                  encodable_resolution_preset_arg.IsNull()
                      ? std::nullopt
                      : std::make_optional<ResolutionPreset>(
                            static_cast<ResolutionPreset>(
                                resolution_preset_arg_value));
              const auto& encodable_enable_audio_arg = args.at(2);
              if (encodable_enable_audio_arg.IsNull()) {
                reply(WrapError("enable_audio_arg unexpectedly null."));
                return;
              }
              const auto& enable_audio_arg =
                  std::get<bool>(encodable_enable_audio_arg);
              api->Create(
                  camera_name_arg,
                  resolution_preset_arg ? &(*resolution_preset_arg) : nullptr,
                  enable_audio_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.initialize" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              api->Initialize(
                  camera_id_arg, [reply](ErrorOr<PlatformSize>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        CustomEncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.dispose" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              ErrorOr<PlatformSize> output = api->Dispose(camera_id_arg);
              if (output.has_error()) {
                reply(WrapError(output.error()));
                return;
              }
              EncodableList wrapped;
              wrapped.push_back(
                  CustomEncodableValue(std::move(output).TakeValue()));
              reply(EncodableValue(std::move(wrapped)));
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.takePicture" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              api->TakePicture(
                  camera_id_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.startVideoRecording" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              const auto& encodable_options_arg = args.at(1);
              if (encodable_options_arg.IsNull()) {
                reply(WrapError("options_arg unexpectedly null."));
                return;
              }
              const auto& options_arg =
                  std::any_cast<const PlatformVideoCaptureOptions&>(
                      std::get<CustomEncodableValue>(encodable_options_arg));
              api->StartVideoRecording(
                  camera_id_arg, options_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.stopVideoRecording" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              api->StopVideoRecording(
                  camera_id_arg, [reply](ErrorOr<std::string>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(
                        EncodableValue(std::move(output).TakeValue()));
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.pausePreview" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              api->PausePreview(camera_id_arg,
                                [reply](std::optional<FlutterError>&& output) {
                                  if (output.has_value()) {
                                    reply(WrapError(output.value()));
                                    return;
                                  }
                                  EncodableList wrapped;
                                  wrapped.push_back(EncodableValue());
                                  reply(EncodableValue(std::move(wrapped)));
                                });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(
        binary_messenger,
        "dev.flutter.pigeon.camera_windows.CameraApi.resumePreview" +
            prepended_suffix,
        &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_camera_id_arg = args.at(0);
              if (encodable_camera_id_arg.IsNull()) {
                reply(WrapError("camera_id_arg unexpectedly null."));
                return;
              }
              const int64_t camera_id_arg = encodable_camera_id_arg.LongValue();
              api->ResumePreview(camera_id_arg,
                                 [reply](std::optional<FlutterError>&& output) {
                                   if (output.has_value()) {
                                     reply(WrapError(output.value()));
                                     return;
                                   }
                                   EncodableList wrapped;
                                   wrapped.push_back(EncodableValue());
                                   reply(EncodableValue(std::move(wrapped)));
                                 });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue CameraApi::WrapError(std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue CameraApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

}  // namespace camera_windows
